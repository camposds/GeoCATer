# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GeoCAT_Analysis
                                 A QGIS plugin
 A QGIS plugin to perform EOO (Extent of Occurrence) and AOO (Area of Occupancy) analysis based on GeoCAT principles
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-09-29
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Diego Sousa Campos
        email                : camposds1@yahoo.com.br
 ***************************************************************************/

"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt, QVariant
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog
from qgis.core import QgsProject, QgsVectorLayer, QgsField, QgsFeature, QgsGeometry, QgsPointXY, QgsRectangle
import csv
import os.path

class GeoCAT_Analysis:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor."""
        self.iface = iface
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(self.plugin_dir, 'i18n', 'GeoCAT_Analysis_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        self.actions = []
        self.menu = self.tr(u'&GeoCATer')
        self.toolbar = self.iface.addToolBar(u'GeoCAT_Analysis')
        self.toolbar.setObjectName(u'GeoCAT_Analysis')

        self.pluginIsActive = False
        self.dockwidget = None

    def tr(self, message):
        """Get the translation for a string using Qt translation API."""
        return QCoreApplication.translate('GeoCAT_Analysis', message)

    def add_action(self, icon_path, text, callback, enabled_flag=True, add_to_menu=True, add_to_toolbar=True, status_tip=None, whats_this=None, parent=None):
        """Add a toolbar icon to the toolbar."""
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(self.menu, action)

        self.actions.append(action)
        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
        icon_path_csv = ':/plugins/geocat_analysis/icon.png'
        self.add_action(icon_path_csv, text=self.tr(u'Import CSV'), callback=self.import_csv, parent=self.iface.mainWindow())

        icon_path_eoo = ':/plugins/geocat_analysis/icon_eoo.png'
        self.add_action(icon_path_eoo, text=self.tr(u'Calculate EOO'), callback=self.calculate_eoo, parent=self.iface.mainWindow())

        icon_path_aoo = ':/plugins/geocat_analysis/icon_aoo.png'
        self.add_action(icon_path_aoo, text=self.tr(u'Calculate AOO'), callback=self.calculate_aoo, parent=self.iface.mainWindow())

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed."""
        if self.dockwidget:
            self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)
        self.pluginIsActive = False

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(self.tr(u'&GeoCATer'), action)
            self.iface.removeToolBarIcon(action)
        del self.toolbar

    def run(self):
        """Run method that loads and starts the plugin."""
        if not self.pluginIsActive:
            self.pluginIsActive = True
            if self.dockwidget is None:
                self.dockwidget = GeoCAT_AnalysisDockWidget()
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)
            self.dockwidget.show()

    def import_csv(self):
        file_path, _ = QFileDialog.getOpenFileName(None, 'Open CSV File', '', 'CSV Files (*.csv)')
        if file_path:
            self.load_csv_data(file_path)

    def load_csv_data(self, file_path):
        try:
            with open(file_path, newline='', encoding='utf-8') as csvfile:
                reader = csv.DictReader(csvfile)
                data = [row for row in reader]
                self.create_occurrence_layer(data)
            self.iface.messageBar().pushMessage("CSV successfully imported!", level=0)
        except Exception as e:
            self.iface.messageBar().pushMessage(f"Error importing CSV: {str(e)}", level=3)

    def create_occurrence_layer(self, data):
        layer = QgsVectorLayer('Point?crs=EPSG:4326', 'Species Occurrences', 'memory')
        provider = layer.dataProvider()
        provider.addAttributes([QgsField('Scientific_Name', QVariant.String)])
        layer.updateFields()

        for row in data:
            if row['Latitude'] and row['Longitude']:
                latitude = float(row['Latitude'])
                longitude = float(row['Longitude'])
                point = QgsPointXY(longitude, latitude)

                feature = QgsFeature()
                feature.setGeometry(QgsGeometry.fromPointXY(point))
                feature.setAttributes([row['Especie']])
                provider.addFeature(feature)

        QgsProject.instance().addMapLayer(layer)

    def calculate_eoo(self):
        layers = QgsProject.instance().mapLayersByName("Species Occurrences")
        if not layers:
            self.iface.messageBar().pushMessage("No 'Species Occurrences' layer found!", level=2)
            return

        layer = layers[0]
        geometries = [feature.geometry() for feature in layer.getFeatures()]

        if not geometries:
            self.iface.messageBar().pushMessage("No geometries found in 'Species Occurrences' layer!", level=2)
            return

        union_geometry = QgsGeometry.unaryUnion(geometries)
        convex_hull = union_geometry.convexHull()

        eoo_layer = QgsVectorLayer('Polygon?crs=EPSG:4326', 'EOO Polygon', 'memory')
        provider = eoo_layer.dataProvider()

        feature = QgsFeature()
        feature.setGeometry(convex_hull)
        provider.addFeature(feature)

        QgsProject.instance().addMapLayer(eoo_layer)
        self.iface.messageBar().pushMessage(f"EOO Calculated: {convex_hull.area():.2f} units²", level=0)

    def calculate_aoo(self, cell_size=2000):
        layers = QgsProject.instance().mapLayersByName("Species Occurrences")
        if not layers:
            self.iface.messageBar().pushMessage("No 'Species Occurrences' layer found!", level=2)
            return

        layer = layers[0]
        extent = layer.extent()

        xmin, ymin, xmax, ymax = extent.xMinimum(), extent.yMinimum(), extent.xMaximum(), extent.yMaximum()

        grid_x = int((xmax - xmin) / cell_size) + 1
        grid_y = int((ymax - ymin) / cell_size) + 1

        aoo_layer = QgsVectorLayer('Polygon?crs=EPSG:4326', 'AOO Grid', 'memory')
        provider = aoo_layer.dataProvider()
        aoo_count = 0

        for i in range(grid_x):
            for j in range(grid_y):
                x0 = xmin + i * cell_size
                y0 = ymin + j * cell_size
                rect = QgsRectangle(x0, y0, x0 + cell_size, y0 + cell_size)
                cell_geom = QgsGeometry.fromRect(rect)

                for feature in layer.getFeatures():
                    if cell_geom.intersects(feature.geometry()):
                        aoo_count += 1
                        provider.addFeature(QgsFeature(cell_geom))
                        break

        QgsProject.instance().addMapLayer(aoo_layer)
        self.iface.messageBar().pushMessage(f"AOO Calculated: {aoo_count * (cell_size ** 2):.2f} units²", level=0)

