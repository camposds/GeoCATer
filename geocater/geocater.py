# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GeoCATer
                                 A QGIS plugin
 Plugin to calculate EOO and AOO for species threat status in conservation studies 
 Generated by Plugin Builder: http: // g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-10-01
        git sha              : $Format:%H$
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os
from PyQt5.QtCore import QSettings, QTranslator, QCoreApplication, Qt
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import QAction, QMessageBox

# Initialize Qt resources from file resources.py
from .resources_rc import *

# Import the code for the DockWidget
from .geocater_dockwidget import GeoCATerDockWidget


class GeoCATer:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: A QGIS interface instance.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        self.canvas = self.iface.mapCanvas()

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(self.plugin_dir, 'i18n', 'GeoCATer_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&GeoCATer')
        self.toolbar = self.iface.addToolBar(u'GeoCATer')
        self.toolbar.setObjectName(u'GeoCATer')

        # Check if icon exists before attempting to use it
        icon_path = ':/plugins/GeoCATer/icon.png'
        if not os.path.exists(icon_path):
            QMessageBox.critical(self.iface.mainWindow(), "GeoCATer", "Icon not found: {}".format(icon_path))
        else:
            self.icon_path = icon_path

    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.
        """
        return QCoreApplication.translate('GeoCATer', message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :param text: Text for the action.
        :param callback: Function to be called when the action is triggered.
        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :param whats_this: Optional text to show in the status bar when the
            action is selected.
        :param parent: Parent widget for the new action. Defaults to None.
        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        """
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(self.menu, action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        # Verifying if the icon path is valid before adding the action
        if hasattr(self, 'icon_path'):
            self.add_action(
                self.icon_path,
                text=self.tr(u'GeoCATer'),
                callback=self.run,
                parent=self.iface.mainWindow())
        else:
            QMessageBox.critical(self.iface.mainWindow(), "GeoCATer", "Failed to load icon for GeoCATer.")

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        for action in self.actions:
            self.iface.removePluginMenu(self.tr(u'&GeoCATer'), action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    def run(self):
        """Run method that performs all the real work"""
        QMessageBox.information(self.iface.mainWindow(), "GeoCATer", "Plugin GeoCATer is running!")

        from qgis.core import QgsProject, QgsGeometry, QgsFeatureRequest, QgsVectorLayer, QgsField, QgsRectangle, \
            QgsCoordinateReferenceSystem, QgsFeature
        from PyQt5.QtCore import QVariant
        from qgis import processing

        class GeoCATer:
            # (restante do código...)

            def run(self):
                """Run method that performs all the real work"""
                # Obter a camada ativa no QGIS
                layer = self.iface.activeLayer()

                if layer is None or not isinstance(layer, QgsVectorLayer):
                    QMessageBox.critical(self.iface.mainWindow(), "GeoCATer",
                                         "Nenhuma camada de pontos ativa foi encontrada.")
                    return

                # Verificar se é uma camada de pontos
                if layer.geometryType() != QgsWkbTypes.PointGeometry:
                    QMessageBox.critical(self.iface.mainWindow(), "GeoCATer",
                                         "A camada ativa não é uma camada de pontos.")
                    return

                # Calcular o EOO (Convex Hull)
                self.calculate_eoo(layer)

                # Calcular o AOO
                self.calculate_aoo(layer)

            def calculate_eoo(self, layer):
                """Calcula o Extent of Occurrence (EOO) usando Convex Hull"""
                features = [f for f in layer.getFeatures()]
                geometries = [f.geometry() for f in features if f.geometry() is not None]

                if not geometries:
                    QMessageBox.warning(self.iface.mainWindow(), "GeoCATer", "Nenhuma geometria válida encontrada.")
                    return

                # Combina todas as geometrias em uma MultiPointGeometry
                multipoint = QgsGeometry.unaryUnion(geometries)

                # Calcular o Convex Hull
                convex_hull = multipoint.convexHull()

                # Criar uma nova camada para o EOO
                eoo_layer = QgsVectorLayer('Polygon?crs=EPSG:4326', 'EOO', 'memory')
                prov = eoo_layer.dataProvider()
                prov.addAttributes([QgsField('ID', QVariant.Int)])
                eoo_layer.updateFields()

                # Adicionar o Convex Hull como uma nova feição
                feat = QgsFeature()
                feat.setGeometry(convex_hull)
                feat.setAttributes([1])  # Atributo ID com valor 1
                prov.addFeature(feat)

                # Adicionar a camada ao projeto
                QgsProject.instance().addMapLayer(eoo_layer)

                QMessageBox.information(self.iface.mainWindow(), "GeoCATer",
                                        "EOO (Convex Hull) calculado e adicionado ao mapa.")

            def calculate_aoo(self, layer, grid_size_km=2):
                """Calcula o Area of Occupancy (AOO) baseado em uma grade de tamanho customizável"""
                extent = layer.extent()

                # Converte o tamanho da célula de quilômetros para graus decimais (simplificação)
                cell_size_deg = grid_size_km / 111  # Aproximadamente 111 km por grau

                # Criar uma grade cobrindo a extensão da camada de pontos
                grid_params = {
                    'TYPE': 2,  # Grid Polygons
                    'EXTENT': extent,
                    'HSPACING': cell_size_deg,
                    'VSPACING': cell_size_deg,
                    'CRS': layer.crs(),
                    'OUTPUT': 'memory:'
                }

                grid_layer = processing.run("qgis:creategrid", grid_params)['OUTPUT']

                # Criar a camada de saída para AOO
                aoo_layer = QgsVectorLayer('Polygon?crs=EPSG:4326', 'AOO', 'memory')
                prov = aoo_layer.dataProvider()
                prov.addAttributes([QgsField('ID', QVariant.Int), QgsField('Occupied', QVariant.Int)])
                aoo_layer.updateFields()

                # Verificar quais células da grade têm ocorrências
                for cell in grid_layer.getFeatures():
                    cell_geom = cell.geometry()
                    request = QgsFeatureRequest().setFilterRect(cell_geom.boundingBox())
                    count = 0
                    for feat in layer.getFeatures(request):
                        if cell_geom.intersects(feat.geometry()):
                            count += 1

                    # Adicionar células ocupadas à camada de AOO
                    if count > 0:
                        new_feat = QgsFeature()
                        new_feat.setGeometry(cell_geom)
                        new_feat.setAttributes([cell.id(), 1])  # Marca como "Occupied"
                        prov.addFeature(new_feat)

                # Adicionar a camada ao projeto
                QgsProject.instance().addMapLayer(aoo_layer)

                QMessageBox.information(self.iface.mainWindow(), "GeoCATer",
                                        f"AOO calculado com células de {grid_size_km}x{grid_size_km} km e adicionado ao mapa.")
